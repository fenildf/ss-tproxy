#!/bin/bash

\trap "exit 1" HUP INT QUIT TERM PIPE

PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

readonly bin=${0##*/}
base_dir="/opt/etc/ssr"
ss_tproxy_config="$base_dir/ss-tproxy.conf"

readonly IPV4_RESERVED_IPADDRS=(
    0.0.0.0/8
    10.0.0.0/8
    100.64.0.0/10
    127.0.0.0/8
    169.254.0.0/16
    172.16.0.0/12
    192.0.0.0/24
    192.0.2.0/24
    192.88.99.0/24
    192.168.0.0/16
    198.18.0.0/15
    198.51.100.0/24
    203.0.113.0/24
    224.0.0.0/4
    240.0.0.0/4
    255.255.255.255/32
)

readonly IPV6_RESERVED_IPADDRS=(
    ::/128
    ::1/128
    ::ffff:0:0/96
    ::ffff:0:0:0/96
    64:ff9b::/96
    100::/64
    2001::/32
    2001:20::/28
    2001:db8::/32
    2002::/16
    fc00::/7
    fe80::/10
    ff00::/8
)

readonly IPV4_PATTERN='^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'
readonly IPV6_PATTERN='^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$'
readonly DOMAIN_PATTERN='^[-_a-z0-9]+\.[-_a-z0-9]+$'

font_bold()     { \printf "\e[1m$*\e[0m";    }
color_red()     { \printf "\e[31m$*\e[0m";   }
color_green()   { \printf "\e[32m$*\e[0m";   }
color_yellow()  { \printf "\e[33m$*\e[0m";   }
color_white()   { \printf "\e[37m$*\e[0m";   }

log_fault() { \echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2 ; exit 1;  }
log_error() { \echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2 ;          }

is_true()           { [[ "$1" = 'true' ]];      }
is_false()          { [[ "$1" = 'false' ]];     }
file_is_exists()    { [[ -f "$1" ]];            }

command_is_exists()     { \which "$1" &>/dev/null;           }
process_is_running()    { \kill -0 "$1" &>/dev/null;         }
tcp_port_is_exists()    { $netstat -lnpt | \grep -qE ":$1[ \t]"; }
udp_port_is_exists()    { $netstat -anpu | \grep -qE ":$1[ \t]"; }

parse_schema() { \cut -d: -f1 <<<"$1" ; }
url_query()     { \grep -oE "\b$1=[^&]*" <<<"$2" | cut -d= -f2; }

chk_dnsserver_is_started() {
    process_is_running "$status_dnsmasq_pid"  ||
    process_is_running "$status_chinadns_pid" ||
    process_is_running "$status_dns2tcp4_pid" ||
    process_is_running "$status_dns2tcp6_pid"
}

chk_iptables_is_started() {
    \iptables  -t mangle -S SSTP_OUTPUT &>/dev/null ||
    \iptables  -t nat    -S SSTP_OUTPUT &>/dev/null ||
    \ip6tables -t mangle -S SSTP_OUTPUT &>/dev/null ||
    \ip6tables -t nat    -S SSTP_OUTPUT &>/dev/null ||
    \ip -4 route show table $ipts_rt_tab 2>/dev/null | \grep -qE '.' ||
    \ip -6 route show table $ipts_rt_tab 2>/dev/null | \grep -qE '.' ||
    \ip -4 rule 2>/dev/null | \grep -qF "fwmark $ipts_rt_mark" ||
    \ip -6 rule 2>/dev/null | \grep -qF "fwmark $ipts_rt_mark"
}

chk_proxyserver_is_started() {
    process_is_running "$status_v2ray_pid"  ||
    process_is_running "$status_ss_pid"
}

chk_base64()   {
    [ -n "$base64_decode" ] && return
    base64_decode=''
    command_is_exists 'base64' || log_fault "command not found: base64"

    \base64 -d       </dev/null &>/dev/null && base64_decode='base64 -d'
    \base64 --decode </dev/null &>/dev/null && base64_decode='base64 --decode'
    [ -n "$base64_decode" ] || log_fault "command args is not support: base64 -d/--decode"
}

chk_iptables_mod()  { iptables $1 -m $2 -h &>/dev/null;      }
chk_kernel_mod()    { \lsmod | \grep -qiE "\b$1\b";  }

is_ipv4_ipts()      { [ "$1" = '-4' ];    }
is_ipv6_ipts()      { [ "$1" = '-6' ];    }
iptables()      {
    is_ipv4_ipts $1 && { "$bin_iptables"  "$@"; return $?; }
    is_ipv6_ipts $1 && { "$bin_ip6tables" "$@"; return $?; }
}

is_global_mode()    { [ "$mode" = 'global' ];   }
is_gfwlist_mode()   { [ "$mode" = 'gfwlist' ];  }
is_chnroute_mode()  { [ "$mode" = 'chnroute' ]; }
is_nonstd_dnsport() { [ "$1" != '53' ];         }

is_ss()        { [ "$proxy_schema" = "ss" ];      }
is_ssr()       { [ "$proxy_schema" = "ssr" ];     }
is_v2ray()     { [ "$proxy_schema" = "vmess" ];   }

is_enabled_udp()    { is_false "$tcponly";      }
is_need_iproute()   { is_true "$tproxy" || is_enabled_udp; }

is_empty_iptschain()    { iptables $1 -t $2 -S $3 | \grep -qE '^-A'; }

is_ipv4_address()   { \grep -qE "$IPV4_PATTERN" <<<"$1";    }
is_ipv6_address()   { \grep -qE "$IPV6_PATTERN" <<<"$1";    }
is_domain_name()    { \grep -qE "$DOMAIN_PATTERN" <<<"$1";  }

is_port_using()     { $netstat -an | \grep -F LISTEN | \grep -qF ":$1" &>/dev/null; }

is_variable_array()     { \declare -p $1 2>/dev/null | \grep -qE -- '^declare -a'; }
is_variable_defined()   { \declare -p $1 &>/dev/null;                            }

set_sysctl_option() {
    local option_name="$1" option_value="$2"
    if command_is_exists "sysctl"; then
        \sysctl -w "$option_name=$option_value" >/dev/null
    else
        local option_path="/proc/sys/${option_name//.//}"
        \echo "$option_value" >$option_path
    fi
}

print_proxy_status() {
    is_v2ray && \
        \printf "$(color_yellow $(jq -rc .outbounds[].streamSettings.wsSettings.headers.host <"$v2ray_config_file" | \echo))";
    is_ssr   && \
        \printf "$(color_yellow $(jq -rc .remarks <"$ssr_config_file"))";
    is_ss   && \
        \printf "$(color_yellow $(jq -rc .server <"$ssr_config_file"))";
}

resolve_hostname_by_hosts() {
    \awk "!/^#/ && /\s+$1\s*$/{print \$1;exit}" /etc/hosts
}

resolve_hostname_by_dig() {
    local addr_family="$1" hostname="$2"
    local ipaddr=$(resolve_hostname_by_hosts "$hostname")
    if [ "$ipaddr" ]; then
        [ "$addr_family" = '-a' ] && \echo "$ipaddr" && return

        if [ "$addr_family" = '-4' ] && is_ipv4_address "$ipaddr"; then
            \echo "$ipaddr"
            return
        fi
        if [ "$addr_family" = '-6' ] && is_ipv6_address "$ipaddr"; then
            \echo "$ipaddr"
            return
        fi
    fi
    [ "$addr_family" = '-a' ] && { \dig "$hostname" | \grep -Ev '^;|\.$' | \head -n1; return; }

    [ "$addr_family" = '-4' ] && local dns_qtype='A' || local dns_qtype='AAAA'
    \dig +short "$dns_qtype" "$hostname" | \grep -Ev '^;|\.$' | \head -n1
}

resolve_hostname_by_getent() {
    local addr_family="$1" hostname="$2"
    [ "$addr_family" = '-4' ] && local db_name='ahostsv4' || local db_name='ahostsv6'
    \getent "$db_name" "$hostname" | \head -n1 | \awk '{print $1}'
}

resolve_hostname_by_ping() {
    local addr_family="$1" hostname="$2"
    [ "$addr_family" = '-a' ] && { \ping -nq -c1 -t1 -W1 "$hostname" | \sed '1{s/[^(]*(//;s/).*//;q}'; return; }
    [ "$addr_family" = '-4' ] && local ping_cmd="$ping4" || local ping_cmd="$ping6"
    $ping_cmd  -nq -c1 -t1 -W1 "$hostname" | \sed '1{s/[^(]*(//;s/).*//;q}';
}

resolve_hostname() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0 ]; do
        ipaddr=$($resolver_func -a "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve hostname error: $1"
    \echo "$ipaddr"
}

resolve_hostname4() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0  ]; do
        ipaddr=$($resolver_func -4 "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve ipv4 hostname error: $1"
    \echo "$ipaddr"
}

resolve_hostname6() {
    local ipaddr=""
    local retry=${2:-3}
    while [ -z "$ipaddr" -a "$retry" -gt 0  ]; do
        ipaddr=$($resolver_func -6 "$1")
        [ -z "$ipaddr" ] && \sleep 1
        let retry=retry-1
    done
    [ -z "$ipaddr" ] && log_fault "resolve ipv6 hostname error: $1"
    \echo "$ipaddr"
}

waiting_network() {
    [ -z "$1" ] && return
    is_ipv4_address "$1" && local ping_cmd="$ping4" || local ping_cmd="$ping6"
    until $ping_cmd -nq -c1 -W1 "$1" >/dev/null; do
        \echo "waiting for network available..."
        \sleep 1
    done
}

ipset_family() {
    [ "$1" = '-4' ] && \echo inet || \echo inet6
}

setname_chnroute() {
    [ "$1" = '-4' ] && \echo $ipset_chnroute_name || \echo ${ipset_privaddr_name}6
}

setname_gfwlist() {
    is_ipv4_ipts $1 && \echo $ipset_gfwlist_name || \echo ${ipset_gfwlist_name}6
}

setname_privaddr() {
    is_ipv4_ipts $1 && \echo $ipset_privaddr_name || \echo ${ipset_privaddr_name}6
}

load_pidfile() {
    \source "$file_dnsserver_pid" || log_fault "load pidfile failed, exit-code: $?"
}

update_pidfile() {
    \echo "status_dnsmasq_pid=$status_dnsmasq_pid"    >$file_dnsserver_pid
    \echo "status_chinadns_pid=$status_chinadns_pid" >>$file_dnsserver_pid
    \echo "status_dns2tcp4_pid=$status_dns2tcp4_pid" >>$file_dnsserver_pid
    \echo "status_dns2tcp6_pid=$status_dns2tcp6_pid" >>$file_dnsserver_pid
    \echo "status_v2ray_pid=$status_v2ray_pid"       >>$file_dnsserver_pid
    \echo "status_ss_pid=$status_ss_pid"             >>$file_dnsserver_pid
}

delete_pidfile() {
    \rm -f $file_dnsserver_pid &>/dev/null
}

save_config() {
  local file="$1"
  shift

  local args= opt= key= val= config="$(\cat "$file")"

  while [[ -n $1 ]]; do
    opt="$1"
    key="$2"
    val="$3"

    shift;shift;
    [[ "$opt" =~ ^- ]] && shift || { val=$key; key=$opt; opt= ; }

    if \grep -qE "^\s*$key=" <<<"$config"; then
        case "$opt" in
        # save config when value is empty
            -e)   args="${args}s#^\s*$key=\(''\|\"\"\|()\|\s\|$\)#$key=$val #;";;
            -r|*) args="${args}s#^\s*$key=[^ \t]*#$key=$val#;";;
        esac
    else
        args="${args}i\\$key=$val;"
    fi
  done
  [ -z "$args" ] && return 0
  \sed -ie "{
  $args
  }" "$file"
}

readonly OVERRIDE_CONFIG=(mode tproxy tcponly selfonly proxy_tcpport proxy_udpport dns_direct dns_direct6 dns_remote dns_remote6 \
    proxy_uri proxy_startcmd proxy_stopcmd file_dnsserver_pid dnsmasq_bind_port dnsmasq_cache_size dnsmasq_cache_time \
    dnsmasq_query_maxcnt dnsmasq_log_enable dnsmasq_log_file dnsmasq_config_file dnsmasq_gfwlist_file dnsmasq_ignore_file \
    chinadns_bind_port chinadns_timeout chinadns_repeat chinadns_fairmode chinadns_gfwlist_mode chinadns_noip_as_chnip \
    chinadns_verbose chinadns_logfile dns2tcp_bind_port dns2tcp_verbose dns2tcp_logfile ipts_if_lo ipts_rt_tab \
    ipts_rt_mark ipts_set_snat ipts_set_snat6 ipts_reddns_onstop ipts_proxy_dst_port opts_ss_netstat \
    opts_ping_cmd_to_use opts_hostname_resolver opts_ip_for_check_net ipset_privaddr_name ipset_gfwlist_name \
    ipset_chnroute_name ipset_timeout file_gfwlist_txt file_gfwlist_ext file_ignlist_ext file_chnroute_set \
    file_chnroute6_set v2ray_config_file ssr_config_file bin_v2ray bin_ssr bin_ss)

config_check_allow_override() {
     echo "${OVERRIDE_CONFIG[@]}" | grep -wqF "$1"
}

load_config() {
    file_is_exists "$ss_tproxy_config" || log_fault "file not found: $ss_tproxy_config"

    local opt_overrides=(${optentries[@]})

    #save_config "$ss_tproxy_config" base_dir "'$base_dir'"
    \source "$ss_tproxy_config" "${arguments[@]}" || log_fault "load config failed, exit-code: $?"

    ## default value
    mode=${mode:-gfwlist}
    tproxy=${tproxy:-false}
    tcponly=${tcponly:-false}
    selfonly=${selfonly:-false}
    proxy_tcpport=${proxy_tcpport:-60080}
    proxy_udpport=${proxy_udpport:-60080}
    dns_direct=${dns_direct:-114.114.114.114}
    dns_direct6=${dns_direct6:-240C::6666}
    dns_remote=${dns_remote:-8.8.8.8#53}
    dns_remote6=${dns_remote6:-2001:4860:4860::8888#53}
    proxy_uri=${proxy_uri:-}
    proxy_startcmd=${proxy_startcmd:-}
    proxy_stopcmd=${proxy_stopcmd:-}

    is_variable_defined proxy_svraddr4 || proxy_svraddr4=()
    is_variable_array proxy_svraddr4 || proxy_svraddr4=($proxy_svraddr4)
    is_variable_defined proxy_svraddr6 || proxy_svraddr6=()
    is_variable_array proxy_svraddr6 || proxy_svraddr6=($proxy_svraddr6)

    file_dnsserver_pid="${file_dnsserver_pid:-$base_dir/.dnsserver.pid}"
    dnsmasq_bind_port=${dnsmasq_bind_port:-53}
    dnsmasq_cache_size=${dnsmasq_cache_size:-4096}
    dnsmasq_cache_time=${dnsmasq_cache_time:-3600}
    dnsmasq_query_maxcnt=${dnsmasq_query_maxcnt:-32}
    dnsmasq_log_enable=${dnsmasq_log_enable:-false}
    dnsmasq_log_file="${dnsmasq_log_file:-$base_dir/dnsmasq.log}"
    dnsmasq_config_file="${dnsmasq_config_file:-$base_dir/dnsmasq.conf}"
    dnsmasq_gfwlist_file="${dnsmasq_gfwlist_file:-$dnsmasq_conf_dir/dnsmasq.gfwlist.conf}"
    dnsmasq_ignore_file="${dnsmasq_ignore_file:-$dnsmasq_conf_dir/dnsmasq.ignore.conf}"
    is_variable_defined dnsmasq_conf_dir || dnsmasq_conf_dir=()
    is_variable_array dnsmasq_conf_dir || dnsmasq_conf_dir=($dnsmasq_conf_dir)
    is_variable_defined dnsmasq_conf_file || dnsmasq_conf_file=()
    is_variable_array dnsmasq_conf_file || dnsmasq_conf_file=($dnsmasq_conf_file)
    is_variable_defined dnsmasq_conf_string || dnsmasq_conf_string=()
    is_variable_array dnsmasq_conf_string || dnsmasq_conf_string=($dnsmasq_conf_string)


    chinadns_bind_port=${chinadns_bind_port:-65353}
    chinadns_timeout=${chinadns_timeout:-3}
    chinadns_repeat=${chinadns_repeat:-1}
    chinadns_fairmode=${chinadns_fairmode:-false}
    chinadns_gfwlist_mode=${chinadns_gfwlist_mode:-false}
    chinadns_noip_as_chnip=${chinadns_noip_as_chnip:-false}
    chinadns_verbose=${chinadns_verbose:-false}
    chinadns_logfile="${chinadns_logfile:-$base_dir/chinadns.log}"
    is_variable_defined chinadns_privaddr4 || chinadns_privaddr4=()
    is_variable_array chinadns_privaddr4 || chinadns_privaddr4=($chinadns_privaddr4)
    is_variable_defined chinadns_privaddr6 || chinadns_privaddr6=()
    is_variable_array chinadns_privaddr6 || chinadns_privaddr6=($chinadns_privaddr6)

    dns2tcp_bind_port=${dns2tcp_bind_port:-65454}
    dns2tcp_verbose=${dns2tcp_verbose:-false}
    dns2tcp_logfile=${dns2tcp_logfile:-$base_dir/dns2tcp.log}

    ipts_if_lo=${ipts_if_lo:-lo}
    ipts_rt_tab=${ipts_rt_tab:-233}
    ipts_rt_mark=${ipts_rt_mark:-0x2333}
    ipts_set_snat=${ipts_set_snat:-true}
    ipts_set_snat6=${ipts_set_snat6:-true}
    ipts_reddns_onstop=${ipts_reddns_onstop:-true}
    ipts_proxy_dst_port=${ipts_proxy_dst_port:-1:65535}

    opts_ss_netstat=${opts_ss_netstat:-auto}
    opts_ping_cmd_to_use=${opts_ping_cmd_to_use:-auto}
    opts_hostname_resolver=${opts_hostname_resolver:-auto}
    opts_overwrite_resolv=${opts_overwrite_resolv:-false}
    opts_ip_for_check_net=${opts_ip_for_check_net:-}

    ipset_privaddr_name=${ipset_privaddr_name:-privaddr}
    ipset_gfwlist_name=${ipset_privaddr_name:-gfwlist}
    ipset_chnroute_name=${ipset_privaddr_name:-chnroute}
    ipset_timeout=${ipset_timeout:-604800‬}

    file_gfwlist_txt="${file_gfwlist_txt:-$base_dir/gfwlist.txt}"
    file_gfwlist_ext="${file_gfwlist_ext:-$base_dir/gfwlist.ext}"
    file_ignlist_ext="${file_ignlist_ext:-$base_dir/ignlist.ext}"
    file_chnroute_set="${file_chnroute_set:-$base_dir/chnroute.set}"
    file_chnroute6_set="${file_chnroute6_set:-$base_dir/chnroute6.set}"

    v2ray_config_file="${v2ray_config_file:-$base_dir/v2ray.conf}"
    ssr_config_file="${ssr_config_file:-$base_dir/shadowsocks.conf}"

    bin_v2ray="${bin_v2ray:-}"
    bin_ssr="${bin_ssr:-}"
    bin_ss="${bin_ss:-}"

    bin_iptables="${bin_iptables:-}"
    bin_ip6tables="${bin_iptables:-}"
    bin_dnsmasq="${bin_dnsmasq:-}"
    bin_chinadnsng="${bin_chinadnsng:-}"
    bin_dns2tcp="${bin_dns2tcp:-}"

    local args="" key= val=
    for optentry in ${opt_overrides[@]}; do
        key=$(\cut -d= -f1 <<<"$optentry")
        var=$(\cut -d= -f2 <<<"$optentry")
        [ -z "$key" ] && continue
        [ -z "$var" ] && var="''"
        config_check_allow_override $key || continue
        eval "$optentry";
        args="$args ${key} ${var}"
    done
    [ -n "$args" ] && save_config "$ss_tproxy_config" $args
}

check_iptable_env() {
    if is_true "$ipv4"; then
        [ -z "$bin_iptables" ] && command_is_exists 'iptables' && bin_iptables="$(\which iptables)"
        [ -x "$bin_iptables" ] || log_fault "command not found: iptables";
    fi
    if is_true "$ipv6"; then
        [ -z "$bin_ip6tables" ] && command_is_exists 'ip6tables' && bin_ip6tables="$(\which ip6tables)"
        [ -x "$bin_ip6tables" ] || log_fault "command not found: ip6tables";
    fi

    is_true "$tproxy" && is_enabled_udp && {
        is_true "$ipv4" && { chk_iptables_mod -4 match || log_fault "iptables match not found. try 'modprobe xt_${match}.ko'";  }
        is_true "$ipv6" && { chk_iptables_mod -6 match || log_fault "ip6tables match not found. try 'modprobe xt_${match}.ko'"; }
    }
    # check iptables match is support
    for match in set mark multiport addrtype conntrack; do
        is_true "$ipv4" && { chk_iptables_mod -4 ${match} || log_fault "iptables match not found. try 'modprobe xt_${match}.ko'"; }
        is_true "$ipv6" && { chk_iptables_mod -6 ${match} || log_fault "ip6tables match not found. try 'modprobe xt_${match}.ko'"; }
    done

    # check kernel modules exists
    local require_mods=(
        'iptable_nat'
        'iptable_mangle'
        'iptable_raw'

        'xt_nat'
        'xt_multiport'
        'xt_tcpudp'
        'ipt_MASQUERADE'

        "nfnetlink"
        "ip_set"
        "ip_set_hash_net"
        "xt_set"

        'nf_tproxy_core'
        'xt_TPROXY'
        'xt_mark'
        'xt_connmark'
        'xt_addrtype'
        'xt_conntrack'
    )
    for mod in ${require_mods[@]}; do
        chk_kernel_mod ${mod}  || log_fault "kernel module not found. try 'modprobe xt_${mod}.ko'";
    done
}

check_proxy_env() {
    { [ -n "$proxy_schema" ] && command_is_exists "base64"; }  || log_fault "command not found: base64"
    { [ -n "$proxy_schema" ] && command_is_exists "jq"; }      || log_fault "command not found: jq"

    if is_v2ray; then
        [ -z "$bin_v2ray" ] && command_is_exists "v2ray" && bin_v2ray="v2ray"
        [ -z "$bin_v2ray" ] && log_fault "bin_v2ray not configure"
        [ -x "$bin_v2ray" ] || log_fault "bin not found: $bin_v2ray"
    elif is_ss || is_ssr; then
        [ -z "$bin_ssr" ] && {
            command_is_exists "ss-local" && bin_ssr="ss-local"
            command_is_exists "ss-redir" && bin_ssr="ss-redir"
        }
        [ -z "$bin_ssr" ] && log_fault "bin_ssr not configure";
        [ -x "$bin_ssr" ] || log_fault "bin not found: $bin_ssr";
        [ -z "$bin_ss" ] && bin_ss="$bin_ssr"
    fi
}

check_dnsmasq_env() {
    [ -z "$bin_dnsmasq" ] && command_is_exists "dnsmasq" && bin_v2ray="$(\which dnsmasq)"
    [ -z "$bin_dnsmasq" ] && log_fault "bin_dnsmasq not configure"
    [ -x "$bin_dnsmasq" ] || log_fault "bin not found: $bin_dnsmasq"
}

check_env() {
    for cmd in ls grep sed awk kill mv rm cat cut touch sort uniq ipset dnsmasq lsmod; do
        command_is_exists $cmd   || log_fault "command not found: $cmd"
    done

    is_need_iproute && { command_is_exists 'ip' || log_fault "command not found: ip"; }
    if ! is_enabled_udp; then
        [ -z "$bin_dns2tcp" ] && command_is_exists 'dns2tcp' && bin_dns2tcp="$(\which dns2tcp)"
        [ -x "$bin_dns2tcp" ] || log_fault "command not found: dns2tcp";
    fi
    if is_chnroute_mode; then
        [ -z "$bin_chinadnsng" ] && command_is_exists 'chinadns-ng' && bin_chinadnsng="$(\which chinadns-ng)"
        [ -x "$bin_chinadnsng" ] || log_fault "command not found: chinadns-ng";
    fi

    if is_true $opts_overwrite_resolv; then
        command_is_exists 'umount' || log_fault "command not found: umount";
        command_is_exists 'mount'  || log_fault "command not found: mount";
        command_is_exists 'mktemp' || log_fault "command not found: mktemp";
        command_is_exists 'chmod'  || log_fault "command not found: chmod";
        command_is_exists 'date'   || log_fault "command not found: date";
    fi

    case "$opts_ss_netstat" in
        auto)
            command_is_exists 'netstat' && netstat='netstat'
            command_is_exists 'ss'      && netstat='ss'
            [ -n "$netstat" ] || log_fault "command not found: ss/netstat"
            ;;
        ss)
            command_is_exists 'ss' && netstat='ss' || log_fault "command not found: ss"
            ;;
        netstat)
            command_is_exists 'netstat' && netstat='netstat' || log_fault "command not found: netstat"
            ;;
        *)
            log_fault "the value of the opts_ss_netstat option is invalid: $opts_ss_netstat"
            ;;
    esac

    case "$opts_ping_cmd_to_use" in
        auto)
            if command_is_exists 'ping' && command_is_exists 'ping6' && ! [ -L "$(\command -v ping6)" ]; then
                ping4='ping'; ping6='ping6'
            elif command_is_exists 'ping'; then
                ping4='ping -4'; ping6='ping -6'
            else
                log_fault "command not found: ping/ping6"
            fi
            ;;
        standalone)
            { command_is_exists 'ping' && command_is_exists 'ping6'; } && { ping4='ping'; ping6='ping6'; } || log_fault "command not found: ping/ping6"
            ;;
        parameter)
            command_is_exists 'ping' && { ping4='ping -4'; ping6='ping -6'; } || log_fault "command not found: ping"
            ;;
        *)
            log_fault "the value of the opts_ping_cmd_to_use option is invalid: $opts_ping_cmd_to_use"
            ;;
    esac

    case "$opts_hostname_resolver" in
        auto)
            if command_is_exists 'dig'; then
                resolver_func='resolve_hostname_by_dig'
            elif command_is_exists 'getent'; then
                resolver_func='resolve_hostname_by_getent'
            elif command_is_exists 'ping'; then
                resolver_func='resolve_hostname_by_ping'
            else
                log_fault "command not found: dig/getent/ping"
            fi
            ;;
        dig)
            command_is_exists 'dig' && resolver_func='resolve_hostname_by_dig' || log_fault "command not found: dig"
            ;;
        getent)
            command_is_exists 'getent' && resolver_func='resolve_hostname_by_getent' || log_fault "command not found: getent"
            ;;
        ping)
            command_is_exists 'ping' && resolver_func='resolve_hostname_by_ping' || log_fault "command not found: ping"
            ;;
        *)
            log_fault "the value of the opts_hostname_resolver option is invalid: $opts_hostname_resolver"
            ;;
    esac
}

check_config() {
    [ -d "$base_dir" ] || log_fault "base directory not exists: $base_dir"
    { is_false "$ipv4" && is_false "$ipv6"; } && log_fault "both ipv4 and ipv6 are disabled, nothing to do"

    file_is_exists "$file_gfwlist_txt"   || log_fault "file not found: $file_gfwlist_txt"
    file_is_exists "$file_gfwlist_ext"   || \touch "$file_gfwlist_ext"
    file_is_exists "$file_ignlist_ext"   || \touch "$file_ignlist_ext"
    file_is_exists "$file_chnroute_set"  || log_fault "file not found: $file_chnroute_set"
    file_is_exists "$file_chnroute6_set" || log_fault "file not found: $file_chnroute6_set"

    if is_v2ray; then
        file_is_exists "$v2ray_config_file" || \touch "$v2ray_config_file"
    elif is_ss || is_ssr; then
        file_is_exists "$ssr_config_file" || \touch "$ssr_config_file"
    fi

    file_is_exists "$file_dnsserver_pid" && load_pidfile

    proxy_schema=$(parse_schema "$proxy_uri")

    { ! is_global_mode && ! is_gfwlist_mode && ! is_chnroute_mode; } && log_fault "the value of the mode option is invalid: $mode"
    { [ -n "$proxy_schema" ] && ! is_ss && ! is_ssr && ! is_v2ray; } && log_fault "unsupport proxy schema: $proxy_schema"

    [ -z "$proxy_svrport" ] && log_fault "the value of the proxy_svrport option is empty"
    [ "${#proxy_svraddr4[@]}" -eq 0 -a "${#proxy_svraddr6[@]}" -eq 0 ] && log_fault "both proxy_svraddr4 and proxy_svraddr6 are empty"
}

resolve_svraddr() {
    if is_true "$ipv4"; then
        proxy_svripv4=()
        for svraddr in "${proxy_svraddr4[@]}"; do
            is_ipv4_address "$svraddr" && local svripv4="$svraddr" || local svripv4=$(resolve_hostname4 "$svraddr")
            proxy_svripv4+=("$svripv4")
        done
    fi

    if is_true "$ipv6"; then
        proxy_svripv6=()
        for svraddr in "${proxy_svraddr6[@]}"; do
            is_ipv6_address "$svraddr" && local svripv6="$svraddr" || local svripv6=$(resolve_hostname6 "$svraddr")
            proxy_svripv6+=("$svripv6")
        done
    fi
}

do_update_chnlist() {
    local chnlist_file="$1"

    { [ -n "$chnlist_file" ] && file_is_exists "$chnlist_file"; } || log_fault "chnlist file not exists"

    local data;
    if [ -z "$gfwlist_file" ]; then
        command_is_exists 'curl' || log_fault "command not found: curl"
        local url='https://raw.github.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf'
        data="$(\curl -4sSkL "$url" || log_fault "download failed, exit-code: $?")"
    else
        data="$(\cat "$chnlist_file")"
    fi
    \echo "$data" | \awk -F/ '{print $2}' >"$file_gfwlist_txt"
    \echo $(color_yellow "you can restart proxy now")
}

readonly GFWLIST_TXT_SCRIPT_STRING='
{
/^[\s!@\[\/]\+/d;
s/^[|.*]\+//;
s/\*[^.*]\+$//;
s/^[a-z?]\+:[^\w]\+//i;
s/\/.*$//;
/[\*+? ]/d;
/\.$/d;
/^[^\.]\+$/d;
/^\s*$/d;
}'

gfwlist_txt_append_domain_names() {
    \printf "twimg.edgesuite.net\n"
    \printf "blogspot.ae\nblogspot.al\nblogspot.am\nblogspot.ba\nblogspot.be\nblogspot.bg\nblogspot.bj\nblogspot.ca\nblogspot.cat\nblogspot.cf\nblogspot.ch\nblogspot.cl\nblogspot.co.at\nblogspot.co.id\nblogspot.co.il\nblogspot.co.ke\nblogspot.com\nblogspot.com.ar\nblogspot.com.au\nblogspot.com.br\nblogspot.com.by\nblogspot.com.co\nblogspot.com.cy\nblogspot.com.ee\nblogspot.com.eg\nblogspot.com.es\nblogspot.com.mt\nblogspot.com.ng\nblogspot.com.tr\nblogspot.com.uy\nblogspot.co.nz\nblogspot.co.uk\nblogspot.co.za\nblogspot.cv\nblogspot.cz\nblogspot.de\nblogspot.dk\nblogspot.fi\nblogspot.fr\nblogspot.gr\nblogspot.hk\nblogspot.hr\nblogspot.hu\nblogspot.ie\nblogspot.in\nblogspot.is\nblogspot.it\nblogspot.jp\nblogspot.kr\nblogspot.li\nblogspot.lt\nblogspot.lu\nblogspot.md\nblogspot.mk\nblogspot.mr\nblogspot.mx\nblogspot.my\nblogspot.nl\nblogspot.no\nblogspot.pe\nblogspot.pt\nblogspot.qa\nblogspot.re\nblogspot.ro\nblogspot.rs\nblogspot.ru\nblogspot.se\nblogspot.sg\nblogspot.si\nblogspot.sk\nblogspot.sn\nblogspot.td\nblogspot.tw\nblogspot.ug\nblogspot.vn\n"
    \printf "google.ac\ngoogle.ad\ngoogle.ae\ngoogle.al\ngoogle.am\ngoogle.as\ngoogle.at\ngoogle.az\ngoogle.ba\ngoogle.be\ngoogle.bf\ngoogle.bg\ngoogle.bi\ngoogle.bj\ngoogle.bs\ngoogle.bt\ngoogle.by\ngoogle.ca\ngoogle.cat\ngoogle.cc\ngoogle.cd\ngoogle.cf\ngoogle.cg\ngoogle.ch\ngoogle.ci\ngoogle.cl\ngoogle.cm\ngoogle.cn\ngoogle.co.ao\ngoogle.co.bw\ngoogle.co.ck\ngoogle.co.cr\ngoogle.co.id\ngoogle.co.il\ngoogle.co.in\ngoogle.co.jp\ngoogle.co.ke\ngoogle.co.kr\ngoogle.co.ls\ngoogle.com\ngoogle.co.ma\ngoogle.com.af\ngoogle.com.ag\ngoogle.com.ai\ngoogle.com.ar\ngoogle.com.au\ngoogle.com.bd\ngoogle.com.bh\ngoogle.com.bn\ngoogle.com.bo\ngoogle.com.br\ngoogle.com.bz\ngoogle.com.co\ngoogle.com.cu\ngoogle.com.cy\ngoogle.com.do\ngoogle.com.ec\ngoogle.com.eg\ngoogle.com.et\ngoogle.com.fj\ngoogle.com.gh\ngoogle.com.gi\ngoogle.com.gt\ngoogle.com.hk\ngoogle.com.jm\ngoogle.com.kh\ngoogle.com.kw\ngoogle.com.lb\ngoogle.com.lc\ngoogle.com.ly\ngoogle.com.mm\ngoogle.com.mt\ngoogle.com.mx\ngoogle.com.my\ngoogle.com.na\ngoogle.com.nf\ngoogle.com.ng\ngoogle.com.ni\ngoogle.com.np\ngoogle.com.om\ngoogle.com.pa\ngoogle.com.pe\ngoogle.com.pg\ngoogle.com.ph\ngoogle.com.pk\ngoogle.com.pr\ngoogle.com.py\ngoogle.com.qa\ngoogle.com.sa\ngoogle.com.sb\ngoogle.com.sg\ngoogle.com.sl\ngoogle.com.sv\ngoogle.com.tj\ngoogle.com.tr\ngoogle.com.tw\ngoogle.com.ua\ngoogle.com.uy\ngoogle.com.vc\ngoogle.com.vn\ngoogle.co.mz\ngoogle.co.nz\ngoogle.co.th\ngoogle.co.tz\ngoogle.co.ug\ngoogle.co.uk\ngoogle.co.uz\ngoogle.co.ve\ngoogle.co.vi\ngoogle.co.za\ngoogle.co.zm\ngoogle.co.zw\ngoogle.cv\ngoogle.cz\ngoogle.de\ngoogle.dj\ngoogle.dk\ngoogle.dm\ngoogle.dz\ngoogle.ee\ngoogle.es\ngoogle.fi\ngoogle.fm\ngoogle.fr\ngoogle.ga\ngoogle.ge\ngoogle.gf\ngoogle.gg\ngoogle.gl\ngoogle.gm\ngoogle.gp\ngoogle.gr\ngoogle.gy\ngoogle.hn\ngoogle.hr\ngoogle.ht\ngoogle.hu\ngoogle.ie\ngoogle.im\ngoogle.io\ngoogle.iq\ngoogle.is\ngoogle.it\ngoogle.je\ngoogle.jo\ngoogle.kg\ngoogle.ki\ngoogle.kz\ngoogle.la\ngoogle.li\ngoogle.lk\ngoogle.lt\ngoogle.lu\ngoogle.lv\ngoogle.md\ngoogle.me\ngoogle.mg\ngoogle.mk\ngoogle.ml\ngoogle.mn\ngoogle.ms\ngoogle.mu\ngoogle.mv\ngoogle.mw\ngoogle.ne\ngoogle.net\ngoogle.nl\ngoogle.no\ngoogle.nr\ngoogle.nu\ngoogle.org\ngoogle.pl\ngoogle.pn\ngoogle.ps\ngoogle.pt\ngoogle.ro\ngoogle.rs\ngoogle.ru\ngoogle.rw\ngoogle.sc\ngoogle.se\ngoogle.sh\ngoogle.si\ngoogle.sk\ngoogle.sm\ngoogle.sn\ngoogle.so\ngoogle.sr\ngoogle.st\ngoogle.td\ngoogle.tg\ngoogle.tk\ngoogle.tl\ngoogle.tm\ngoogle.tn\ngoogle.to\ngoogle.tt\ngoogle.vg\ngoogle.vu\ngoogle.ws\n"
}

do_update_gfwlist() {
    local gfwlist_file="$1"

    { [ -n "$gfwlist_file" ] && file_is_exists "$gfwlist_file"; } || log_fault "gfwlist file not exists"

    chk_base64

    if [ -z "$gfwlist_file" ]; then
        command_is_exists 'curl'   || log_fault "command not found: curl"
        local url='https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt'
        \curl -4sSkL "$url" | $base64_decode 2>/dev/null | filter_gfwlist >"$file_gfwlist_txt" || \
            log_fault "download failed, exit-code: $?"
    else
        \cat "$gfwlist_file" | $base64_decode 2>/dev/null| filter_gfwlist >"$file_gfwlist_txt"
    fi

    \echo "write to $file_gfwlist_txt" $(color_green "successful")
    \echo $(color_yellow "you can restart proxy now")
}

filter_gfwlist() {
    \cat | { \sed -e "$GFWLIST_TXT_SCRIPT_STRING"; gfwlist_txt_append_domain_names; } | \sort | \uniq
}

do_update_chnroute() {
    local chnroute_file="$1"

    { [ -n "$chnroute_file" ] && file_is_exists "$chnroute_file"; } || log_fault "chnroute file not exists"

    local data;

    if [ -z "$gfwlist_file" ]; then
        command_is_exists 'curl' || log_fault "command not found: curl"
        local url='http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'
        data="$(\curl -4sSkL "$url" || log_fault "download failed, exit-code: $?")"
    else
        data="$(\cat "$chnroute_file")"
    fi
    {
        \echo "create chnroute hash:net family inet"
        \echo "$data" | \grep CN | \grep ipv4 | \awk -F'|' '{printf("add chnroute %s/%d\n", $4, 32-log($5)/log(2))}'
    } >"$file_chnroute_set"
    {
        \echo "create chnroute6 hash:net family inet6"
        \echo "$data" | \grep CN | \grep ipv6 | \awk -F'|' '{printf("add chnroute6 %s/%d\n", $4, $5)}'
    } >"$file_chnroute6_set"
    \echo $(color_yellow "you can restart proxy now")
}

_convert_dnsmasq_domain() {
    local from_file="$1" to_file="$2" dns_server=$3 dns_server6=$4 ipset_prename=$5

    local ipset_name=($({ is_true "$ipv4" && \echo $ipset_prename; }) $({ is_true "$ipv6" && \echo ${ipset_prename}6; }))
    local awk_script="$(
        is_true "$ipv4" && \echo "print 'server = /'\$1'/$dns_server';"
        is_true "$ipv6" && \echo "print 'server = /'\$1'/$dns_server6';"
        \echo "print 'ipset = /'\$1'/"$(\echo ${ipset_name[@]} | \sed 's/ /,/')
    )"
    \grep -qE "$DOMAIN_PATTERN" "$from_file" | \
        \awk "{${awk_script}}" >"$to_file"

    if is_true "$ipv4"; then
        \grep -qE "$IPV4_PATTERN" "$from_file" | \awk '{print "add '$ipset_prename' "$1}'  | \ipset -exist
    elif is_true "$ipv6"; then
        \grep -qE "$IPV6_PATTERN" "$from_file" | \awk '{print "add '$ipset_prename'6 "$1}' | \ipset -exist
    fi
}

start_dnsserver_global() {
    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$dnsmasq_common_config")
$(is_true "$ipv4" && \echo "server = $dns_remote")
$(is_true "$ipv6" && \echo "server = $dns_remote6")
conf-file = $dnsmasq_ignore_file
EOF
    _convert_dnsmasq_domain "$file_ignlist_ext" "$dnsmasq_ignore_file" $dns_direct $dns_direct6 privaddr

    status_dnsmasq_pid=$(\dnsmasq --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsserver_gfwlist() {
    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$dnsmasq_common_config")
$(is_true "$ipv4" && \echo "server = $dns_direct")
$(is_true "$ipv6" && \echo "server = $dns_direct6")
conf-file = $dnsmasq_gfwlist_file
EOF
    \echo $(color_yellow "parsing gfwlist ...")

    _convert_dnsmasq_domain "$file_gfwlist_txt" "$dnsmasq_gfwlist_file" $dns_remote $dns_remote6 gfwlist

    status_dnsmasq_pid=$(\dnsmasq --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsserver_chnroute() {
    local chinadns_args="-b 127.0.0.1 -l $chinadns_bind_port -o $chinadns_timeout -p $chinadns_repeat"
    is_true "$chinadns_noip_as_chnip" && chinadns_args+=" -n"
    is_true "$chinadns_gfwlist_mode" && chinadns_args+=" -g-"
    is_true "$chinadns_fairmode" && chinadns_args+=" -f"
    is_true "$chinadns_verbose" && chinadns_args+=" -v"
    if is_true "$ipv4" && is_true "$ipv6"; then
        chinadns_args+=" -c $dns_direct,$dns_direct6"
        chinadns_args+=" -t $dns_remote,$dns_remote6"
    elif is_true "$ipv4"; then
        chinadns_args+=" -c $dns_direct"
        chinadns_args+=" -t $dns_remote"
    else
        chinadns_args+=" -c $dns_direct6"
        chinadns_args+=" -t $dns_remote6"
    fi

    is_true "$ipv4" && \grep -vE '^[0-9]' "$file_chnroute_set" | awk '{print "add chnroute "$1}'   | \ipset -exist
    is_true "$ipv6" && \grep -vE '^[0-9]' "$file_chnroute6_set" | awk '{print "add chnroute6 "$1}' | \ipset -exist
    is_true "$ipv4" && for addr in "${chinadns_privaddr4[@]}"; do \echo "add chnroute $addr";  done | \ipset -exist
    is_true "$ipv6" && for addr in "${chinadns_privaddr6[@]}"; do \echo "add chnroute6 $addr"; done | \ipset -exist

    if is_true "$chinadns_gfwlist_mode"; then
        local gfwlist_domain_string=$(\cat $file_gfwlist_txt; \grep -E '^@' $file_gfwlist_ext | \cut -c2-)
        status_chinadns_pid=$(\chinadns-ng $chinadns_args <<<"$gfwlist_domain_string" &>>$chinadns_logfile & \echo $!)
    else
        status_chinadns_pid=$(\chinadns-ng $chinadns_args </dev/null &>>$chinadns_logfile & \echo $!)
    fi

    \cat <<EOF >"$dnsmasq_config_file"
$(\echo "$dnsmasq_common_config")
server = 127.0.0.1#$chinadns_bind_port
conf-file = ${dnsmasq_ignore_file}
EOF

    _convert_dnsmasq_domain "$file_ignlist_ext" "$dnsmasq_ignore_file" $dns_direct $dns_direct6 privaddr

    status_dnsmasq_pid=$(\dnsmasq --keep-in-foreground --conf-file=$dnsmasq_config_file & \echo $!)
}

start_dnsmasq_daemon() {
    local dnsmasq_append_config=("${dnsmasq_conf_string[@]}")
    if is_true "$ipv4"; then
        for ((i = 0; i < ${#proxy_svraddr4[@]}; ++i)); do
            local server_host="${proxy_svraddr4[i]}"
            local server_addr="${proxy_svripv4[i]}"
            if is_domain_name "$server_host"; then
                dnsmasq_append_config+=("address = /$server_host/$server_addr")
            fi
        done
    fi
    if is_true "$ipv6"; then
        for ((i = 0; i < ${#proxy_svraddr6[@]}; ++i)); do
            local server_host="${proxy_svraddr6[i]}"
            local server_addr="${proxy_svripv6[i]}"
            if is_domain_name "$server_host"; then
                dnsmasq_append_config+=("address = /$server_host/$server_addr")
            fi
        done
    fi

    local dnsmasq_common_config=$(\cat <<EOF
$(is_true "$dnsmasq_log_enable" && \echo 'log-queries')
log-facility = $dnsmasq_log_file
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$(\dnsmasq --help | \grep -qF min-cache-ttl && \echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = $dnsmasq_bind_port
dns-forward-max = $dnsmasq_query_maxcnt
$(for append_config in "${dnsmasq_append_config[@]}"; do \echo "$append_config"; done)
$(for conf_dir_arg in "${dnsmasq_conf_dir[@]}"; do \echo "conf-dir = $conf_dir_arg"; done)
$(for conf_file_arg in "${dnsmasq_conf_file[@]}"; do \echo "conf-file = $conf_file_arg"; done)
EOF
)

    if ! is_enabled_udp; then
        local original_dns_remote="$dns_remote"
        local original_dns_remote6="$dns_remote6"
        dns_remote="127.0.0.1#$dns2tcp_bind_port"
        dns_remote6="::1#$dns2tcp_bind_port"
    fi

    start_ipset

    if is_global_mode; then
        start_dnsserver_global
    elif is_gfwlist_mode; then
        start_dnsserver_gfwlist
    elif is_chnroute_mode; then
        start_dnsserver_chnroute
    fi

    if ! is_enabled_udp; then
        local dns2tcp_listen_addr4="$dns_remote"
        local dns2tcp_listen_addr6="$dns_remote6"
        local dns2tcp_remote_addr4="$original_dns_remote"
        local dns2tcp_remote_addr6="$original_dns_remote6"
        dns_remote="$original_dns_remote"
        dns_remote6="$original_dns_remote6"
        if is_true "$ipv4"; then
            local dns2tcp_args="-L $dns2tcp_listen_addr4 -R $dns2tcp_remote_addr4"
            is_true "$dns2tcp_verbose" && dns2tcp_args+=" -v"
            status_dns2tcp4_pid=$(\dns2tcp $dns2tcp_args </dev/null &>>$dns2tcp_logfile & \echo $!)
        fi
        if is_true "$ipv6"; then
            local dns2tcp_args="-L $dns2tcp_listen_addr6 -R $dns2tcp_remote_addr6"
            is_true "$dns2tcp_verbose" && dns2tcp_args+=" -v"
            status_dns2tcp6_pid=$(\dns2tcp $dns2tcp_args </dev/null &>>$dns2tcp_logfile & \echo $!)
        fi
    fi

    update_pidfile
}

stop_dnsserver() {
    [ -n "$status_dnsmasq_pid" ]    && kill -9 $status_dnsmasq_pid  &>/dev/null
    [ -n "$status_chinadns_pid" ]   && kill -9 $status_chinadns_pid &>/dev/null
    [ -n "$status_dns2tcp4_pid" ]   && kill -9 $status_dns2tcp4_pid &>/dev/null
    [ -n "$status_dns2tcp6_pid" ]   && kill -9 $status_dns2tcp6_pid &>/dev/null

    stop_proxyserver
    delete_pidfile
}

#  clears cache and then
#  re-loads /etc/hosts and /etc/ethers and any file given by
#  --dhcp-hostsfile, --dhcp-optsfile or --addn-hosts
_flush_dnscache() {
    local SIGNAL=${1:-SIGHUP}
    kill -$SIGNAL "$status_dnsmasq_pid"
}

modify_resolvconf() {
    [ -z "$opts_overwrite_resolv" ] && return
    if is_false "$opts_overwrite_resolv"; then
        while \umount /etc/resolv.conf &>/dev/null; do true; done
        local temp_resolv_conf=$(\mktemp)
        \chmod 0644 $temp_resolv_conf
        \mount -o bind $temp_resolv_conf /etc/resolv.conf
        \rm -f $temp_resolv_conf
    fi
    \echo "# Generated by ss-tproxy at $(\date '+%F %T')" >/etc/resolv.conf
    is_true "$ipv4" && \echo "nameserver 127.0.0.1" >>/etc/resolv.conf
    is_true "$ipv6" && \echo "nameserver ::1" >>/etc/resolv.conf
}

restore_resolvconf() {
    [ -z "$opts_overwrite_resolv" ] && return
    if is_false "$opts_overwrite_resolv"; then
        while \umount /etc/resolv.conf &>/dev/null; do true; done
    else
        \echo "# Generated by ss-tproxy at $(\date '+%F %T')" >/etc/resolv.conf
        is_true "$ipv4" && \echo "nameserver $dns_direct" >>/etc/resolv.conf
        is_true "$ipv6" && \echo "nameserver $dns_direct6" >>/etc/resolv.conf
    fi
}

trigger_proxy_startcmd() {
    \eval "$proxy_startcmd" || log_fault "failed to start local proxy process, exit-code: $?"
}

trigger_proxy_stopcmd() {
    \eval "$proxy_stopcmd" &>/dev/null
}

enable_ipforward() {
    is_true "$ipv4" && set_sysctl_option 'net.ipv4.ip_forward' 1
    is_true "$ipv6" && set_sysctl_option 'net.ipv6.conf.all.forwarding' 1
}

disable_icmpredir() {
    for dir in $(\ls /proc/sys/net/ipv4/conf); do
        set_sysctl_option "net.ipv4.conf.$dir.send_redirects" 0
    done
}

delete_ipset_gfwlist() {
    \ipset -X gfwlist  &>/dev/null
    \ipset -X gfwlist6 &>/dev/null
}

flush_ipset_gfwlist() {
    \ipset -F gfwlist  &>/dev/null
    \ipset -F gfwlist6 &>/dev/null
}

delete_ipset_chnroute() {
    \ipset -X privaddr  &>/dev/null
    \ipset -X privaddr6 &>/dev/null
    \ipset -X chnroute  &>/dev/null
    \ipset -X chnroute6 &>/dev/null
}

flush_ipset_chnroute() {
    \ipset -F privaddr  &>/dev/null
    \ipset -F privaddr6 &>/dev/null
    \ipset -F chnroute  &>/dev/null
    \ipset -F chnroute6 &>/dev/null
}

do_delete_ipset_gfwlist() {
    chk_dnsserver_is_started && log_fault "dnsmasq is running, can not delete"
    chk_iptables_is_started && log_fault "iptables rule is using, can not delete"
    delete_ipset_gfwlist
}

delete_iproute2() {
    \ip -4 rule  del   table $ipts_rt_tab &>/dev/null
    \ip -4 route flush table $ipts_rt_tab &>/dev/null

    \ip -6 rule  del   table $ipts_rt_tab &>/dev/null
    \ip -6 route flush table $ipts_rt_tab &>/dev/null
}

delete_iptables_mangle() {
    iptables $1 -t mangle -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null

    iptables $1 -t mangle -F SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -F SSTP_OUTPUT      &>/dev/null
    iptables $1 -t mangle -F SSTP_RULE        &>/dev/null

    iptables $1 -t mangle -X SSTP_PREROUTING  &>/dev/null
    iptables $1 -t mangle -X SSTP_OUTPUT      &>/dev/null
    iptables $1 -t mangle -X SSTP_RULE        &>/dev/null
}

delete_iptables_nat() {
    iptables $1 -t nat -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -D POSTROUTING -j SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null

    iptables $1 -t nat -F SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -F SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -F SSTP_OUTPUT      &>/dev/null
    iptables $1 -t nat -F SSTP_RULE        &>/dev/null

    iptables $1 -t nat -X SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -X SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -X SSTP_OUTPUT      &>/dev/null
    iptables $1 -t nat -X SSTP_RULE        &>/dev/null
}

_show_iptables() {
    \echo "$(color_green "==> iptables-mangle <==")"
    iptables $1 -t mangle -nvL --line-numbers | \sed -n '{
#/^Chain PREROUTING/,/^$/p;
#/^Chain OUTPUT/,/^$/p;
/^Chain SSTP_PREROUTING/,/^$/p;
/^Chain SSTP_OUTPUT/,/^$/p;
/^Chain SSTP_RULE/,/^$/p;
}'
    \echo
    \echo "$(color_green "==> iptables-nat <==")"
    iptables $1 -t nat -nvL --line-numbers | \sed -n '{
#/^Chain PREROUTING/,/^$/p;
#/^Chain POSTROUTING/,/^$/p;
#/^Chain OUTPUT/,/^$/p;
/^Chain SSTP_PREROUTING/,/^$/p;
/^Chain SSTP_POSTROUTING/,/^$/p;
/^Chain SSTP_OUTPUT/,/^$/p;
/^Chain SSTP_RULE/,/^$/p;
}'
}

do_show_iptables() {
    is_true "$ipv4" && _show_iptables -4
    { is_true "$ipv4" && is_true "$ipv6"; } && \echo
    is_true "$ipv6" && _show_iptables -6
}

create_dnsredir() {
    is_false "$ipts_reddns_onstop" && return

    local direct_dns_ip
    is_ipv4_ipts $1 && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    iptables $1 -t nat -N SSTP_PREROUTING  &>/dev/null
    iptables $1 -t nat -N SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -A SSTP_PREROUTING  -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j DNAT --to-destination $direct_dns_ip
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p udp -d $direct_dns_ip --dport 53 -j MASQUERADE
}

create_snatrule() {
    local set_snat_rule='false'
    { is_ipv4_ipts $1 && is_true "$ipts_set_snat";  } && set_snat_rule='true'
    { is_ipv6_ipts $1 && is_true "$ipts_set_snat6"; } && set_snat_rule='true'
    is_false "$set_snat_rule" && return

    iptables $1 -t nat -N SSTP_POSTROUTING &>/dev/null
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -m conntrack --ctstate SNAT,DNAT   -j RETURN
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p tcp --syn                       -j MASQUERADE
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p udp -m conntrack --ctstate NEW  -j MASQUERADE
    iptables $1 -t nat -A SSTP_POSTROUTING -m addrtype ! --src-type LOCAL -p icmp -m conntrack --ctstate NEW -j MASQUERADE
}

create_iptschain() {
    iptables $1 -t nat -nL SSTP_PREROUTING  &>/dev/null && iptables $1 -t nat -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t nat -nL SSTP_POSTROUTING &>/dev/null && iptables $1 -t nat -A POSTROUTING -j SSTP_POSTROUTING
}

create_postrule() {
    chk_dnsserver_is_started && return
    { is_false "$ipts_reddns_onstop" && is_false "$ipts_set_snat" && is_false "$ipts_set_snat6"; } && return
    is_true "$ipv4" && { create_dnsredir -4; create_snatrule -4; create_iptschain -4;  }
    is_true "$ipv6" && { create_dnsredir -6; create_snatrule -6; create_iptschain -6; }
}

do_stop_iptables() {
    delete_iptables_mangle -4
    delete_iptables_mangle -6
    delete_iptables_nat -4
    delete_iptables_nat -6
}

_delete_unused_iptchains() {
    if is_empty_iptschain $1 mangle SSTP_PREROUTING; then
        iptables $1 -t mangle -D PREROUTING -j SSTP_PREROUTING
        iptables $1 -t mangle -X SSTP_PREROUTING
    fi
    if is_empty_iptschain $1 mangle SSTP_OUTPUT; then
        iptables $1 -t mangle -D OUTPUT -j SSTP_OUTPUT
        iptables $1 -t mangle -X SSTP_OUTPUT
    fi
    if is_empty_iptschain $1 nat SSTP_PREROUTING; then
        iptables $1 -t nat -D PREROUTING -j SSTP_PREROUTING
        iptables $1 -t nat -X SSTP_PREROUTING
    fi
    if is_empty_iptschain $1 nat SSTP_OUTPUT; then
        iptables $1 -t nat -D OUTPUT -j SSTP_OUTPUT
        iptables $1 -t nat -X SSTP_OUTPUT
    fi
    if is_empty_iptschain $1 nat SSTP_POSTROUTING; then
        iptables $1 -t nat -D POSTROUTING -j SSTP_POSTROUTING
        iptables $1 -t nat -X SSTP_POSTROUTING
    fi
}

delete_unused_iptchains() {
    _delete_unused_iptchains -4
    _delete_unused_iptchains -6
}

start_iptables_pre_rules() {
    iptables $1 -t mangle -N SSTP_PREROUTING
    iptables $1 -t mangle -N SSTP_OUTPUT
    iptables $1 -t nat    -N SSTP_PREROUTING
    iptables $1 -t nat    -N SSTP_OUTPUT
    iptables $1 -t nat    -N SSTP_POSTROUTING

    if is_need_iproute; then
        local iproute2_family="$1"
        \ip $iproute2_family route add local default dev $ipts_if_lo table $ipts_rt_tab
        \ip $iproute2_family rule  add fwmark $ipts_rt_mark          table $ipts_rt_tab
    fi
}

start_iptables_post_rules() {
    iptables $1 -t mangle -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t mangle -A OUTPUT      -j SSTP_OUTPUT
    iptables $1 -t nat    -A PREROUTING  -j SSTP_PREROUTING
    iptables $1 -t nat    -A OUTPUT      -j SSTP_OUTPUT
    iptables $1 -t nat    -A POSTROUTING -j SSTP_POSTROUTING
}

start_iptables_tproxy_mode() {
    local loopback_addr
    is_ipv4_ipts "$1" && loopback_addr="127.0.0.1" || loopback_addr="::1"

    local svr_ip_array=()
    is_ipv4_ipts "$1" && svr_ip_array=("${proxy_svripv4[@]}") || svr_ip_array=("${proxy_svripv6[@]}")

    local direct_dns_ip
    is_ipv4_ipts "$1" && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts "$1" && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts "$1" && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"

    local gfwlist_setname=$(setname_gfwlist $1)
    local chnroute_setname=$(setname_chnroute $1)
    local privaddr_setname=$(setname_privaddr $1)

    ######################### SSTP_RULE (tcp and udp) #########################

    iptables $1 -t mangle -N SSTP_RULE

    iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --restore-mark
    iptables $1 -t mangle -A SSTP_RULE -m mark --mark $ipts_rt_mark -j RETURN

    for svr_ip in "${svr_ip_array[@]}"; do
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
    done

    if is_enabled_udp; then
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $direct_dns_ip --dport 53               -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j RETURN
    else
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port -j RETURN
    fi

    if is_gfwlist_mode; then
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    elif is_global_mode; then
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    elif is_chnroute_mode; then
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j MARK --set-mark $ipts_rt_mark
        is_enabled_udp && iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
    fi

    iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --save-mark

    ######################### SSTP_OUTPUT/SSTP_PREROUTING #########################

    if is_nonstd_dnsport "$dnsmasq_bind_port"; then
        iptables $1 -t nat -A SSTP_OUTPUT -p udp -d $loopback_addr --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
    fi

    iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
    is_enabled_udp && iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE

    iptables $1 -t mangle -A SSTP_PREROUTING -i $ipts_if_lo -m mark ! --mark $ipts_rt_mark -j RETURN

    if is_false "$selfonly"; then
        if is_nonstd_dnsport "$dnsmasq_bind_port"; then
            is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j RETURN
            iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
        fi

        iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
        is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE
    fi

    iptables $1 -t mangle -A SSTP_PREROUTING -p tcp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_tcpport
    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -p udp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport

    create_snatrule $1
}

start_iptables_redirect_mode() {
    local loopback_addr
    is_ipv4_ipts $1 && loopback_addr="127.0.0.1" || loopback_addr="::1"

    local gfwlist_setfamily
    is_ipv4_ipts $1 && gfwlist_setfamily="inet" || gfwlist_setfamily="inet6"

    local svr_ip_array=()
    is_ipv4_ipts $1 && svr_ip_array=("${proxy_svripv4[@]}") || svr_ip_array=("${proxy_svripv6[@]}")

    local direct_dns_ip
    is_ipv4_ipts $1 && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts $1 && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts $1 && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"

    local gfwlist_setname=$(setname_gfwlist $1)
    local chnroute_setname=$(setname_chnroute $1)
    local privaddr_setname=$(setname_privaddr $1)

    ######################### SSTP_RULE (for tcp) #########################

    iptables $1 -t nat -N SSTP_RULE

    for svr_ip in "${svr_ip_array[@]}"; do
        iptables $1 -t nat -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
    done

    if ! is_enabled_udp; then
        iptables $1 -t nat -A SSTP_RULE -p tcp -d $remote_dns_ip --dport $remote_dns_port --syn -j REDIRECT --to-ports $proxy_tcpport
    fi

    if is_gfwlist_mode; then
        iptables $1 -t nat -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    elif is_global_mode; then
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    elif is_chnroute_mode; then
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
        iptables $1 -t nat -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port --syn -j REDIRECT --to-ports $proxy_tcpport
    fi

    ######################### SSTP_RULE (for udp) #########################

    if is_enabled_udp; then
        iptables $1 -t mangle -N SSTP_RULE

        iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --restore-mark
        iptables $1 -t mangle -A SSTP_RULE -m mark --mark $ipts_rt_mark -j RETURN

        for svr_ip in "${svr_ip_array[@]}"; do
            iptables $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
        done

        iptables $1 -t mangle -A SSTP_RULE -p udp -d $direct_dns_ip --dport 53               -j RETURN
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark
        iptables $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j RETURN

        if is_gfwlist_mode; then
            iptables $1 -t mangle -A SSTP_RULE -p udp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        elif is_global_mode; then
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        elif is_chnroute_mode; then
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $privaddr_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN
            iptables $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -m conntrack --ctstate NEW -j MARK --set-mark $ipts_rt_mark
        fi

        iptables $1 -t mangle -A SSTP_RULE -j CONNMARK --save-mark
    fi

    ######################### SSTP_OUTPUT/SSTP_PREROUTING #########################

    if is_nonstd_dnsport "$dnsmasq_bind_port"; then
        iptables $1 -t nat -A SSTP_OUTPUT -p udp -d $loopback_addr --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
    fi

    iptables $1 -t nat -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
    is_enabled_udp && iptables $1 -t mangle -A SSTP_OUTPUT -m addrtype --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE

    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -i $ipts_if_lo -m mark ! --mark $ipts_rt_mark -j RETURN

    if is_false "$selfonly"; then
        if is_nonstd_dnsport "$dnsmasq_bind_port"; then
            is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j RETURN
            iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL --dst-type LOCAL -p udp --dport 53 -j REDIRECT --to-ports $dnsmasq_bind_port
        fi

        iptables $1 -t nat -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p tcp -j SSTP_RULE
        is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -m addrtype ! --src-type LOCAL ! --dst-type LOCAL -p udp -j SSTP_RULE
    fi

    is_enabled_udp && iptables $1 -t mangle -A SSTP_PREROUTING -p udp -m mark --mark $ipts_rt_mark -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport

    create_snatrule $1
}

start_iptables() {
    check_iptable_env

    is_true "$ipv4" && start_iptables_pre_rules -4
    is_true "$ipv6" && start_iptables_pre_rules -6

    if is_true "$tproxy"; then
        is_true "$ipv4" && start_iptables_tproxy_mode -4
        is_true "$ipv6" && start_iptables_tproxy_mode -6
    else
        is_true "$ipv4" && start_iptables_redirect_mode -4
        is_true "$ipv6" && start_iptables_redirect_mode -6
    fi

    is_true "$ipv4" && start_iptables_post_rules -4
    is_true "$ipv6" && start_iptables_post_rules -6
}

create_ipset() {
    local ipset_setfamily=$(ipset_family $1)
    local gfwlist_setname=$(setname_gfwlist $1)
    local privaddr_setname=$(setname_privaddr $1)
    local grep_pattern=$({ [ "$1" = '-4' ] && \echo "$IPV4_PATTERN" || \echo "$IPV6_PATTERN"; })

    local privaddr_array=()
    is_ipv4_ipts $1 && privaddr_array=("${IPV4_RESERVED_IPADDRS[@]}") || privaddr_array=("${IPV6_RESERVED_IPADDRS[@]}")

    if is_global_mode || is_chnroute_mode; then
        \ipset create -exist $privaddr_setname hash:net family $ipset_setfamily timeout $ipset_timeout
        for privaddr in "${privaddr_array[@]}"; do \echo "-A $privaddr_setname $privaddr"; done | \ipset -R -exist &>/dev/null
        \grep -E "$grep_pattern" $file_ignlist_ext | while \read ip_addr; do
            \echo "-A $privaddr_setname $ip_addr";
        done | ipset -R -exist &>/dev/null
    elif is_gfwlist_mode; then
        \ipset create -exist $gfwlist_setname hash:net family $ipset_setfamily timeout $ipset_timeout
        \grep -iE "$grep_pattern" $file_gfwlist_ext | while \read ip_addr; do
            \echo "-A $gfwlist_setname $ip_addr";
        done | \ipset -R -exist &>/dev/null
    fi
}

start_ipset() {
    is_true "$ipv4" && create_ipset -4
    is_true "$ipv6" && create_ipset -6
}

start_proxyserver() {
    check_proxy_env

    [ -z "$proxy_schema" ] && return 99

    local exit_status=
    is_ss && parse_ss && { start_ssr; exit_status=$?; }
    is_ssr && parse_ssr && { start_ssr; exit_status=$?; }
    is_v2ray && parse_vmess && { start_v2ray; exit_status=$?; }

    [ "$exit_status" -eq 0 ] && update_pidfile

    return $exit_status
}

stop_proxyserver() {
    [ -n "$status_v2ray_pid" ]      && kill $status_v2ray_pid       &>/dev/null
    [ -n "$status_ss_pid" ]         && kill $status_ss_pid          &>/dev/null
}

start_ssr() {
    status_ss_pid=$($bin_ssr -c "$v2ray_config_file" &>/dev/null & \echo $! || \
    log_error "shadowsocks.conf error, can't start shadowsocks!";)
}

start_v2ray() {
    status_v2ray_pid=$($bin_v2ray -config "$v2ray_config_file" &>/dev/null & \echo $! || \
    log_error "V2ray.conf error, can't start V2ray!";)
}

parse_proxy() {
    proxy_uri="$1"
    proxy_schema=$(parse_schema "$1")
    { ! is_ss && ! is_ssr && ! is_v2ray; } && log_fault "unsupport proxy schema: $proxy_schema"

    is_ss && parse_ss
    is_ssr && parse_ssr
    is_v2ray && parse_vmess

    stop_proxyserver
    start_proxyserver && \
    save_config "$ss_tproxy_config" -a proxy_uri "'$proxy_uri'"

    \echo $(color_white $(\printf "%-15s" "parse success:"))

    is_ss    && \echo $(print_proxy_status)
    is_ssr   && \echo $(print_proxy_status)
    is_v2ray && \echo $(print_proxy_status)
}

parse_ssr() {
    chk_base64
    local proxy_ssr_config=$(\sed '{s/ssr:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$proxy_uri" | $base64_decode 2>/dev/null)
    [ -n "$proxy_ssr_config" ] || log_fault "invalid ssr URI, unable to resolve!"

    local proxy_ssr_srvhost=$(\cut -d: -f1 <<<"$proxy_ssr_config")
    local proxy_ssr_srvport=$(\cut -d: -f2 <<<"$proxy_ssr_config")
    local proxy_ssr_protocol=$(\cut -d: -f3 <<<"$proxy_ssr_config")
    local proxy_ssr_method=$(\cut -d: -f4 <<<"$proxy_ssr_config")
    local proxy_ssr_obfs=$(\cut -d: -f5 <<<"$proxy_ssr_config")
    local pass_and_param=$(\cut -d: -f6 <<<"$proxy_ssr_config" | \sed '{s#/\|?\|/?#:#;s/-/+/g;s/_/\//g;}')
    local proxy_ssr_passwd="$(\cut -d: -f1 <<<"$pass_and_param" | $base64_decode 2>/dev/null)"
    local proxy_ssr_params="$(\cut -d: -f2 <<<"$pass_and_param")"
    local proxy_ssr_obfs_param=$(url_query obfsparam "$proxy_ssr_params" | $base64_decode 2>/dev/null)
    local proxy_ssr_proto_param=$(url_query protoparam "$proxy_ssr_params" | $base64_decode 2>/dev/null)
    local proxy_ssr_remarks=$(url_query remarks "$proxy_ssr_params" | $base64_decode 2>/dev/null)
    local proxy_ssr_group=$(url_query group "$proxy_ssr_params" | $base64_decode 2>/dev/null)

    if is_true "$ipv6"; then
        local proxy_ssr_ip=$(resolve_hostname6 "$proxy_ssr_srvhost")
        is_ipv6_address $proxy_ssr_ip || proxy_ssr_ip=
    else
        local proxy_ssr_ip=$(resolve_hostname4 "$proxy_ssr_srvhost")
        is_ipv4_address $proxy_ssr_ip || proxy_ssr_ip=
    fi

    local ssr_config='{"server":"'$proxy_ssr_srvhost'","server_port":"'$proxy_ssr_srvport'","local_addressr":"'$proxy_ssr_loaddr'","local_port":"'$proxy_tcpport'","encrypt_method":"'$proxy_ssr_method'","passrword":"'$proxy_ssr_passwd'","protocol":"'$proxy_ssr_protocol'","protocolparam":"'$proxy_ssr_proto_param'","obfs":"'$proxy_ssr_obfs'","obfsparam":"'$proxy_ssr_obfs_param'","remarks":"'$proxy_ssr_remarks'","group":"'$proxy_ssr_group'"}'

    jq . <<<"${ssr_config}" >/tmp/shadowsocks.conf || log_fault "shadowsocks config failed"

    \mv /tmp/shadowsocks.conf "$ssr_config_file" && \
    \echo "shadowsocks.conf resolve" $(color_green "succeed !!")
}

parse_ss() {
    chk_base64
    local proxy_ss_config=$(\sed -e '{s/ss:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$proxy_uri" | $base64_decode 2>/dev/null)
    [ -n "$proxy_ss_config" ] || return 1

    local proxy_ss_srvhost=$(\cut -d@ -f2 <<<"$proxy_ss_config" | \cut -d: -f1)
    local proxy_ss_srvport=$(\cut -d@ -f2 <<<"$proxy_ss_config" | \cut -d: -f2)
    local proxy_ss_method=$(\cut -d@ -f1 <<<"$proxy_ss_config" | \cut -d: -f1)
    local proxy_ss_passwd="$(\cut -d@ -f1 <<<"$proxy_ss_config" | \cut -d: -f2)"
    local proxy_ss_loaddr='0.0.0.0'
    local proxy_ss_fastopen='false'
    local proxy_ss_timeout='0'

    if is_true "$ipv6"; then
        local proxy_ss_ip=$(resolve_hostname6 "$proxy_ss_srvhost")
        is_ipv6_address $proxy_ss_ip || proxy_ss_ip=
    else
        local proxy_ss_ip=$(resolve_hostname4 "$proxy_ss_srvhost")
        is_ipv4_address $proxy_ss_ip || proxy_ss_ip=
    fi

    local ss_config='{"server":"'$proxy_ss_srvhost'","server_port":"'$proxy_ss_srvport'","local_address":"'$proxy_ss_loaddr'","local_port":"'$proxy_tcpport'","encrypt_method":"'$proxy_ss_method'","password":"'$proxy_ss_passwd'"}'

    jq . <<<"${ss_config}" >/tmp/shadowsocks.conf || return 2

    \mv /tmp/shadowsocks.conf "$ssr_config_file" && \
    \echo "shadowsocks.conf resolve" $(color_green "succeed !!")
}

parse_vmess() {
    chk_base64
    # base64 decode
    local proxy_vmess_config=$(\sed -e '{s/vmess:\/\///g;s/-/+/g;s/_/\//g;}' <<<"$proxy_uri" | $base64_decode 2>/dev/null | \jq -c  .)
    [ -n "$proxy_vmess_config" ] || log_fault "invalid vmess URI, unable to resolve!"

    local proxy_vmess_add=$(\echo "$proxy_vmess_config"  | \jq -cr .add)
    local proxy_vmess_port=$(\echo "$proxy_vmess_config" | \jq -cr .port)
    local proxy_vmess_id=$(\echo "$proxy_vmess_config"   | \jq -cr .id)
    local proxy_vmess_aid=$(\echo "$proxy_vmess_config"  | \jq -cr .aid)
    local proxy_vmess_net=$(\echo "$proxy_vmess_config"  | \jq -cr .net)
    local proxy_vmess_type=$(\echo "$proxy_vmess_config" | \jq -cr .type)
    local proxy_vmess_host=$(\echo "$proxy_vmess_config" | \jq -c .host)
    local proxy_vmess_path=$(\echo "$proxy_vmess_config" | \jq -cr .path)
    local proxy_vmess_tls=$(\echo "$proxy_vmess_config"  | \jq -cr .tls)

    if is_true "$ipv6"; then
        local proxy_vmess_ip=$(resolve_hostname6 "$proxy_vmess_add")
        is_ipv6_address $proxy_vmess_ip || proxy_vmess_ip=
    else
        local proxy_vmess_ip=$(resolve_hostname4 "$proxy_vmess_add")
        is_ipv4_address $proxy_vmess_ip || proxy_vmess_ip=
    fi

    [[ "$proxy_vmess_path" == '' ]] && proxy_vmess_path="null"
    [[ "$proxy_vmess_net" != 'quic' ]] && proxy_vmess_host=$(\sed 's/,/","/g' <<<"$proxy_vmess_host")

    is_domain_name "$proxy_vmess_add" && dnsmasq_conf_string+=("address = /$proxy_vmess_add/$proxy_vmess_ip")

    ## outBounds
    out_set='{"vnext":[{"address":"'${proxy_vmess_add}'","port":'${proxy_vmess_port}',"users":[{"id":"'${proxy_vmess_id}'","security":"auto","alterId": '${proxy_vmess_aid}'}]}]}'
    out_stream='{"network":"'${proxy_vmess_net}'","security":"none"}'

    case ${proxy_vmess_net} in
        'tcp')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "tcpSettings":{}}')
            ;;
        'kcp')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "kcpSettings":{}}')
            ;;
        'ws')
            ws_settings='{"path":"'${proxy_vmess_path}'"}'
            [[ "$proxy_vmess_host" != '""' ]] && ws_settings=$(\echo ${ws_settings} | \jq -c '. += {"headers":{"host":'${proxy_vmess_host}'}}');
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "wsSettings": '${ws_settings}'}')
            ;;
        'h2')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "httpSettings":{"path":"'${proxy_vmess_path}'","host":['${proxy_vmess_host}']}}')
            ;;
        'quic')
            out_stream=$(\echo "$out_stream" | \jq -c '. | {network, security, "quicSettings":{"security":'${proxy_vmess_host}',"key":"'${proxy_vmess_path}'","header":{"type": "none"}}}')
            ;;
    esac

    if [ "$proxy_vmess_tls" == 'tls' ]; then
        [ "$proxy_vmess_host" == '""' ] && proxy_vmess_host="null"
        out_stream=$(\echo "$out_stream" | \jq -c '. += {"tlsSettings":{"allowInsecure":true,"serverName":"'${proxy_vmess_host}'"}} | to_entries | map(if .key == "security" then . + {"value":"tls"} else . end ) | from_entries')
    fi
    local outbound='[{"protocol":"vmess","settings":'${out_set}',"tag": "out-0","streamSettings":'${out_stream}'}]'

    ## inBounds
    [ "${tproxy}" == 'true' ] && proxy_vmess_tproxy='"tproxy"' || proxy_vmess_tproxy='"redirect"'

    \grep -qE '^[0-9][0-9]+$' <<<"$proxy_tcpport" || proxy_tcpport=60080
    \grep -qE '^[0-9][0-9]+$' <<<"$proxy_udpport" || proxy_udpport=60080

    # save config
    save_config "$ss_tproxy_config" \
        proxy_tcpport "$proxy_tcpport" \
        proxy_udpport "$proxy_udpport" \
        proxy_svraddr4 "($proxy_vmess_ip)" \
        proxy_svrport "$proxy_vmess_port" \
        -e opts_ip_for_check_net "$proxy_vmess_ip"

    local in_stream='{"sockopt":{"mark":0,"tcpFastOpen":true,"tproxy":'${proxy_vmess_tproxy}'}}'
    local inbound;

    if [[ "$proxy_tcpport" != "$proxy_udpport" ]]; then
        inbound='[{"protocol":"dokodemo-door","listen":"0.0.0.0","port":'${proxy_tcpport}',"settings":{"network": "tcp","followRedirect":true },"streamSettings":'${in_stream}'},{"protocol":"dokodemo-door","listen":"0.0.0.0","port":'${proxy_udpport}',"settings":{"network": "udp","followRedirect":true },"streamSettings":'${in_stream}'}]'
    else
        inbound='[{"protocol":"dokodemo-door","listen":"0.0.0.0","port":'${proxy_tcpport}',"settings":{"network": "tcp,udp","followRedirect":true },"streamSettings":'${in_stream}'}]'
    fi

    ## v2ray log
    local v_log='{"loglevel": "warning","error": "/var/log/v2ray-error.log","access": "/var/log/v2ray-access.log"}'

    local v2ray_config='{"log":'${v_log}',"dns":{},"stats":{},"inbounds":'${inbound}',"outbounds":'${outbound}',"routing":{},"policy":{},"reverse":{},"transport":{}}'

    jq . <<<"${v2ray_config}" >/tmp/v2ray.conf || return 2

    if "$bin_v2ray" -test -config /tmp/v2ray.conf | \grep -qF 'Configuration OK'; then
        mv /tmp/v2ray.conf "$v2ray_config_file" && \
        \echo "v2ray.conf resolve" $(color_green "succeed !!")
    else
        log_fault "v2ray.conf resolve failed"
    fi
}

_add_delete_domain() {
    local action="$1";
    local domain="$2";
	local file_name="$3";
    local customfile_name="$4";
    local ipset_name=;
	local dns_name=;
    local is_ipv4=false;
    local is_ipv6=false;

    is_domain_name "$domain" || { \echo $(color_red "invalid domain $domain") && return 1; }
    is_ipv4_address "$domain" && is_ipv4=true
    is_ipv6_address "$domain" && is_ipv6=true

    if is_global_mode || is_chnroute_mode; then
        is_true $ipv4 && ipset_name=privaddr  && dns_name=$dns_direct
        is_true $ipv6 && ipset_name=privaddr6 && dns_name=$dns_direct6
    elif is_gfwlist_mode; then
        is_true $ipv4 && ipset_name=gfwlist  && dns_name=$dns_remote
        is_true $ipv6 && ipset_name=gfwlist6 && dns_name=$dns_remote6
    fi

    [ -n "$ipset_name" ] || log_fault "ipset name error"

    if [ "$action" = "add" ]; then
        if is_true $is_ipv4 || is_true $is_ipv6 ; then
            \ipset add -exist $ipset_name "$domain"
        elif [ -n "$file_name" ]; then
            \grep -qF "^${domain}$" "$customfile_name" && \echo $(color_red "domain $domain exists") && return 1
            \grep -qF "/$domain/" "$file_name"         && \echo $(color_red "domain $domain exists") && return 1

            \echo "$domain" >>"$customfile_name"
            \echo "server = /$domain/$dns_name\nipset = /$domain/$ipset_name"   >>"$file_name"
        fi

        \echo "domain added" $(color_green "$domain")
    elif [ "$action" = "delete" ]; then
        if is_true $is_ipv4 || is_true $is_ipv6  ;then
            \ipset del -exist  $ipset_name "$domain"
        elif [ -n "$file_name" ]; then
            \local ip=$(resolve_hostname "$domain")
            [ -n "$ip" ] || { \echo $(color_red "$domain resolve error"); return 1; }
            \sed -ie "#^${domain}$#d" "$customfile_name"
            \sed -ie "#/${domain}/#d" "$file_name"
            ipset del -exist $ipset_name $ip
        fi

        \echo "domain deleted" $(color_red "$domain")
    fi
}

do_modify_gfwlist() {
    local action="$1";shift;
    for domain in "$@"; do
        _add_delete_domain $action $domain "$dnsmasq_gfwlist_file" "$file_gfwlist_ext"
    done

	reload_dnsserver
}

do_modify_ignlist() {
    local action="$1";shift;
    for domain in "$@"; do
        _add_delete_domain $action $domain "$dnsmasq_ignore_file" "$file_ignlist_ext"
    done

	reload_dnsserver
}

do_set_mode() {
    [ "$mode" = "$1" ] && return 0;
    [ "$1" != "global" -o "$1" != "gfwlist" -o "$1" != "chnroute" ] && log_fault "mode $m not support"
    mode="$1"
    save_config "$ss_tproxy_config" mode $mode

    do_stop
    do_start
}

start_dnsserver() {
    check_dnsmasq_env
    restore_resolvconf
    resolve_svraddr
    trigger_proxy_startcmd
    start_dnsmasq_daemon
    modify_resolvconf
}

do_show() {
    case "$1" in
        ipt|iptables)
            do_show_iptables
        ;;
        ''|-h|--help|h|help)
            \echo "Usage: $bin show" $(color_white "[SERVICE]");
            \echo "       $bin show" $(color_white "iptables");
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin update help\"");
            exit 1
        ;;
    esac
}

do_update() {
    case "$1" in
        gfw|gfwlist)
            do_update_gfwlist "${@:1}"
            ;;
        chn|chnlist)
            do_update_chnlist "${@:1}"
            ;;
        chnroute)
            do_update_chnroute "${@:1}"
            ;;
        ''|-h|--help|h|help)
            \echo "Usage: $bin update" $(color_white "[SERVICE]");
            \echo "       $bin update" $(color_white "gfwlist");
            \echo "       $bin update" $(color_white "chnlist");
            \echo "       $bin update" $(color_white "chnroute");
        ;;
        a|all)
            do_update gfwlist
            do_update chnlist
            do_update chnroute
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin update help\"");
            exit 1
        ;;
    esac
}

do_start() {
    local srv="$1"

    case "$srv" in
        p|proxy)
            chk_proxyserver_is_started || {
                start_proxyserver
            }
        ;;
        d|dns|dnsmasq)
            process_is_running $status_dnsmasq_pid || {
                waiting_network "$opts_ip_for_check_net"
                start_dnsserver
            }
        ;;
        i|ipt|iptables)
            chk_iptables_is_started || {
                enable_ipforward
                disable_icmpredir
                start_iptables
            }
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin start" $(color_white "[SERVICE]");
            \echo "       $bin start" $(color_white "proxy");
            \echo "       $bin start" $(color_white "dnsmasq");
            \echo "       $bin start" $(color_white "iptables");
        ;;
        '')
            check_proxy_env
            check_iptable_env

            [ "$(type -t pre_start)" = 'function' ] && pre_start "$@"
            do_start proxy
            do_start dnsmasq
            do_start iptables
            [ "$(type -t post_start)" = 'function' ] && post_start "$@"
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin start help\"");
            exit 1
        ;;
    esac
}

do_stop() {
    local srv="$1"

    case "$srv" in
        p|proxy)
            chk_proxyserver_is_started && {
                stop_proxyserver
            }
        ;;
        d|dns|dnsmasq)
            process_is_running $status_dnsmasq_pid && {
                restore_resolvconf
                stop_dnsserver
                trigger_proxy_stopcmd
            }
        ;;
        i|ipt|iptables)
            chk_iptables_is_started && {
                delete_iproute2
                do_stop_iptables
                delete_ipset_chnroute
                delete_ipset_gfwlist
            }
        ;;
        -h|--help|h|help)
            \echo "Usage: $bin stop" $(color_white "[SERVICE]");
            \echo "       $bin stop" $(color_white "proxy");
            \echo "       $bin stop" $(color_white "dnsmasq");
            \echo "       $bin stop" $(color_white "iptables");
        ;;
        '')
            [ "$(type -t pre_stop)" = 'function' ] && pre_stop "$@"
            do_stop iptables
            do_stop dnsmasq
            do_stop proxy
            [ "$(type -t post_stop)" = 'function' ] && post_stop "$@"
        ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin stop help\"");
            exit 1
        ;;
    esac
}

reload_dnsserver() {
    process_is_running $status_dnsmasq_pid || log_fault "dnsmasq is not running"

    _flush_dnscache && \
    \echo -n "reload dnsmasq: " && \
    \echo $(color_green "success") || \
    \echo $(color_red "failed")
}

reload_proxyserver() {
    stop_proxyserver
    start_proxyserver && \
    {
        \echo -n "reload "
        is_ss       && \echo -n " ss ";
        is_ssr      && \echo -n " ssr ";
        is_v2ray    && \echo -n " v2ray ";
        \echo -n ':';
    } && \
    \echo $(color_green "success") || \
    \echo $(color_red "failed")
}

reload_iptables() {
    delete_iproute2
    do_stop_iptables
    delete_ipset_chnroute

    do_start iptables
}

do_reload() {
    local srv=$1
    case "$srv" in
        d|dns|dnacache|dnsmasq)
            reload_dnsserver
            ;;
        ipt|iptables)
            reload_iptables
            ;;
        ipset)
            do_flush_ipset
            ;;
        -h|--help|h|help)
            \echo "Usage: $bin reload" $(color_white "[SERVICE]");
            \echo "       $bin reload" $(color_white "[SERVICE]");
            \echo "       $bin reload" $(color_white "dnsmasq");
            exit
            ;;
        '')
            reload_dnsserver;
            reload_iptables
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin reload help\"");
            exit 1
            ;;
    esac
    exit
}

do_status() {
    local max=15

    \printf "%-${max}s%s\n" "mode:" $mode

    if [ -n "$proxy_schema" ]; then
        is_v2ray && {
        process_is_running $status_v2ray_pid && \
        \printf "%-${max}s%s %s\n" "v2ray/tcp:" $(color_green '[running]') "($(print_proxy_status))" || \
        \printf "%-${max}s%s\n" "v2ray/tcp:" $(color_red '[stopped]');
        }
        is_ssr   && {
        process_is_running $status_ss_pid && \
        \printf "%-${max}s%s %s\n" "ssr/tcp:" $(color_green '[running]') "($(print_proxy_status))" || \
        \printf "%-${max}s%s\n" "ssr/tcp:" $(color_red '[stopped]')
        }
        is_ss   && {
        process_is_running $status_ss_pid && \
        \printf "%-${max}s%s %s\n" "ss /tcp:" $(color_green '[running]') "($(print_proxy_status))"
        \printf "%-${max}s%s\n" "ss /tcp:" $(color_red '[stopped]')
        }
    fi
    tcp_port_is_exists $proxy_tcpport && \
        \printf "%-${max}s%s\n" "pxy/tcp:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "pxy/tcp:" $(color_red '[stopped]')

    if is_enabled_udp; then
        udp_port_is_exists $proxy_udpport && \
        \printf "%-${max}s%s\n" "pxy/udp:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "pxy/udp:" $(color_red '[stopped]')
    fi
    process_is_running $status_dnsmasq_pid && \
        \printf "%-${max}s%s\n" "dnsmasq:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dnsmasq:" $(color_red '[stopped]')
    if is_chnroute_mode; then
        process_is_running $status_chinadns_pid && \
        \printf "%-${max}s%s\n" "chinadns:" $(color_green '[running]')|| \
        \printf "%-${max}s%s\n" "chinadns:" $(color_red '[stopped]')
    fi
    if ! is_enabled_udp; then
        is_true "$ipv4" && { process_is_running $status_dns2tcp4_pid && \
        \printf "%-${max}s%s\n" "dns2tcp4:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dns2tcp4:" $(color_red '[stopped]');
        }
        is_true "$ipv6" && { process_is_running $status_dns2tcp6_pid && \
        \printf "%-${max}s%s\n" "dns2tcp6:" $(color_green '[running]') || \
        \printf "%-${max}s%s\n" "dns2tcp6:" $(color_red '[stopped]');
         }
    fi
}

do_flush_ipset() {
    case "$1" in
        gfw|gfwlist)
            flush_ipset_gfwlist
            ;;
        chn|chnroute)
            flush_ipset_chnroute
            ;;
        help)
            \echo "Usage: $bin flush ipset" $(color_white "[SERVICE]");
            \echo "       $bin flush ipset" $(color_white "gfwlist");
            \echo "       $bin flush ipset" $(color_white "chnroute");
            exit
            ;;
        '')
            do_flush_ipset chnroute;
            do_flush_ipset gfwlist;
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin flush ipset help\"");
            exit 1
            ;;
    esac
    exit
}

do_flush() {
    local srv=$1
    case "$srv" in
        ipset)
            do_flush_ipset ${@:1}
            ;;
        ipt|iptables)
            do_stop_iptables
            ;;
        ip|iproute)
            delete_iproute2
            ;;
        d|dns|dnscache|dnsmasq)
            reload_dnsserver
            ;;
        help)
            \echo "Usage: $bin flush" $(color_white "[SERVICE]");
            \echo "       $bin flush" $(color_white "ipset");
            \echo "       $bin flush" $(color_white "iptables");
            \echo "       $bin flush" $(color_white "iproute");
            exit
            ;;
        '')
            reload_dnsserver;
            reload_proxyserver
            ;;
        *)
            \echo $(color_yellow "unknown service:") $(color_red "$srv");\
            \echo $(color_white "try \"$bin flush help\"");
            exit 1
            ;;
    esac
    exit
}

do_version() {
    \echo "ss-tproxy v5.0"
    exit
}

do_help() {
    \cat <<EOF
Usage: $bin <COMMAND> [-x] [-c cfgfile] [name=value...]
COMMAND := {
    start               start ss-tproxy
    stop                stop ss-tproxy
    restart             restart ss-tproxy
    reload              reload configure
    status              status of ss-tproxy
    show                show rules
    flush               delete rules

    update              update domain list
    parse               config proxy from URI

    set-mode            change run mode manual

    add-domain          add a domain to gfwlist
    del-domain          delete a domain from gfwlist
    add-ignore          add a domain to ignore list
    del-ignore          delete a domain from ignore list

    version             show version and exit
    help                show help and exit
}
Specify the -x option for debugging of bash scripts
Specify the -c option to use given ss-tproxy cfgfile
Specify the name=value to override ss-tproxy configs
Issues or bug report: https://github.com/zwcway/ss-tproxy
EOF
    exit
}

main() {
    local arguments=()
    optentries=()

    local arglist=("$@")
    local help_flag=false ver_flag=false
    for ((i = 0; i < ${#arglist[@]}; ++i)); do
        local arg="${arglist[i]}"
        if [ "$arg" = '-x' ]; then
            set -x
        elif [ "$arg" = '-c' ]; then
            ss_tproxy_config="${arglist[++i]}"
            base_dir="${ss_tproxy_config%/*}"
        elif [ "$arg" = '-v' ]; then
            ver_flag=true
        elif [ "$arg" = '-h' ]; then
            help_flag=true
        elif [[ "$arg" =~ ^- ]]; then
            \echo $(color_yellow "unknown option: ") $(color_red "$arg")
            do_help
        elif [[ "$arg" =~ ^= ]]; then
            \echo $(color_yellow "unknown option: ") $(color_red "$arg")
            do_help
        elif \grep -qF '=' <<<"$arg"; then
            optentries+=("$arg")
        else
            arguments+=("$arg")
        fi
    done

    is_true $help_flag && do_help
    is_true $ver_flag && do_version

    if [ "${#arguments[@]}" -eq 0 -a "${#optentries[@]}" -eq 0 ]; then
        \echo "$(color_yellow "Missing necessary options")"
        do_help
    fi

    load_config
    check_config
    check_env

    [ "${#arguments[@]}" -eq 0 ] && return;

    case "${arguments[0]}" in
        start)                          do_start "${arguments[@]:1}"; do_status;;
        stop)                           do_stop "${arguments[@]:1}"; do_status;;
        restart)                        do_stop "${arguments[@]:1}"; do_status; \echo; do_start "${arguments[@]:1}"; do_status;;
        s|status)                       do_status;;
        show)                           do_show "${arguments[@]:1}";;
        f|flush)                        do_flush;;
        r|reload)                       do_reload "${arguments[@]:1}";;
        u|update)                       do_update "${arguments[@]:1}";;

        parse)                          parse_proxy "${arguments[@]:1}";;

        add|add-domain)                 do_modify_gfwlist add "${arguments[@]:1}";;
        del|del-domain)                 do_modify_gfwlist delete "${arguments[@]:1}";;
        add-ignore)                     do_modify_ignlist add "${arguments[@]:1}";;
        del-ignore)                     do_modify_ignlist delete "${arguments[@]:1}";;

        mode|set-mode)                  do_set_mode "${arguments[@]:1}";;
        v|version)                      do_version;;
        h|help)                         do_help;;
        *)                              \echo "$(color_yellow "Unknown option: ${arguments[0]}")"; do_help; return 1;;
    esac
    return 0
}
main "$@"
